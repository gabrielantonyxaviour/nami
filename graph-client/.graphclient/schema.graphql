schema {
  query: Query
  subscription: Subscription
}

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Query {
  disaster(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): disaster
  disasters(
    skip: Int = 0
    first: Int = 100
    orderBy: disaster_orderBy
    orderDirection: OrderDirection
    where: disaster_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [disaster!]!
  beneficiary(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): beneficiary
  beneficiaries(
    skip: Int = 0
    first: Int = 100
    orderBy: beneficiary_orderBy
    orderDirection: OrderDirection
    where: beneficiary_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [beneficiary!]!
  funding(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): funding
  fundings(
    skip: Int = 0
    first: Int = 100
    orderBy: funding_orderBy
    orderDirection: OrderDirection
    where: funding_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [funding!]!
  claim(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): claim
  claims(
    skip: Int = 0
    first: Int = 100
    orderBy: claim_orderBy
    orderDirection: OrderDirection
    where: claim_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [claim!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  disasterDescriptive(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): disasterDescriptive
  disasterDescriptives(
    skip: Int = 0
    first: Int = 100
    orderBy: disasterDescriptive_orderBy
    orderDirection: OrderDirection
    where: disasterDescriptive_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [disasterDescriptive!]!
  fundReleaseDescriptive(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): fundReleaseDescriptive
  fundReleaseDescriptives(
    skip: Int = 0
    first: Int = 100
    orderBy: fundReleaseDescriptive_orderBy
    orderDirection: OrderDirection
    where: fundReleaseDescriptive_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [fundReleaseDescriptive!]!
  kintoToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoToken
  kintoTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoToken_orderBy
    orderDirection: OrderDirection
    where: kintoToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoToken!]!
  kintoAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoAccount
  kintoAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoAccount_orderBy
    orderDirection: OrderDirection
    where: kintoAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoAccount!]!
  kintoBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoBalance
  kintoBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoBalance_orderBy
    orderDirection: OrderDirection
    where: kintoBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoBalance!]!
  kintoTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoTransfer
  kintoTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoTransfer_orderBy
    orderDirection: OrderDirection
    where: kintoTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoTransfer!]!
  kintoVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoVault
  kintoVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoVault_orderBy
    orderDirection: OrderDirection
    where: kintoVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoVault!]!
  polToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polToken
  polTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: polToken_orderBy
    orderDirection: OrderDirection
    where: polToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polToken!]!
  polAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polAccount
  polAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polAccount_orderBy
    orderDirection: OrderDirection
    where: polAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polAccount!]!
  polBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polBalance
  polBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polBalance_orderBy
    orderDirection: OrderDirection
    where: polBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polBalance!]!
  polTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polTransfer
  polTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polTransfer_orderBy
    orderDirection: OrderDirection
    where: polTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polTransfer!]!
  polVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polVault
  polVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: polVault_orderBy
    orderDirection: OrderDirection
    where: polVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polVault!]!
  ethToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethToken
  ethTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: ethToken_orderBy
    orderDirection: OrderDirection
    where: ethToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethToken!]!
  ethAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethAccount
  ethAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: ethAccount_orderBy
    orderDirection: OrderDirection
    where: ethAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethAccount!]!
  ethBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethBalance
  ethBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: ethBalance_orderBy
    orderDirection: OrderDirection
    where: ethBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethBalance!]!
  ethTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethTransfer
  ethTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: ethTransfer_orderBy
    orderDirection: OrderDirection
    where: ethTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethTransfer!]!
  ethVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethVault
  ethVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: ethVault_orderBy
    orderDirection: OrderDirection
    where: ethVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethVault!]!
  baseToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseToken
  baseTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: baseToken_orderBy
    orderDirection: OrderDirection
    where: baseToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseToken!]!
  baseAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseAccount
  baseAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: baseAccount_orderBy
    orderDirection: OrderDirection
    where: baseAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseAccount!]!
  baseBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseBalance
  baseBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: baseBalance_orderBy
    orderDirection: OrderDirection
    where: baseBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseBalance!]!
  baseTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseTransfer
  baseTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: baseTransfer_orderBy
    orderDirection: OrderDirection
    where: baseTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseTransfer!]!
  baseVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseVault
  baseVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: baseVault_orderBy
    orderDirection: OrderDirection
    where: baseVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseVault!]!
  scrollToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollToken
  scrollTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollToken_orderBy
    orderDirection: OrderDirection
    where: scrollToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollToken!]!
  scrollAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollAccount
  scrollAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollAccount_orderBy
    orderDirection: OrderDirection
    where: scrollAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollAccount!]!
  scrollBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollBalance
  scrollBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollBalance_orderBy
    orderDirection: OrderDirection
    where: scrollBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollBalance!]!
  scrollTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollTransfer
  scrollTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollTransfer_orderBy
    orderDirection: OrderDirection
    where: scrollTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollTransfer!]!
  scrollVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollVault
  scrollVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollVault_orderBy
    orderDirection: OrderDirection
    where: scrollVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollVault!]!
}

type Subscription {
  disaster(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): disaster
  disasters(
    skip: Int = 0
    first: Int = 100
    orderBy: disaster_orderBy
    orderDirection: OrderDirection
    where: disaster_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [disaster!]!
  beneficiary(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): beneficiary
  beneficiaries(
    skip: Int = 0
    first: Int = 100
    orderBy: beneficiary_orderBy
    orderDirection: OrderDirection
    where: beneficiary_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [beneficiary!]!
  funding(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): funding
  fundings(
    skip: Int = 0
    first: Int = 100
    orderBy: funding_orderBy
    orderDirection: OrderDirection
    where: funding_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [funding!]!
  claim(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): claim
  claims(
    skip: Int = 0
    first: Int = 100
    orderBy: claim_orderBy
    orderDirection: OrderDirection
    where: claim_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [claim!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  disasterDescriptive(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): disasterDescriptive
  disasterDescriptives(
    skip: Int = 0
    first: Int = 100
    orderBy: disasterDescriptive_orderBy
    orderDirection: OrderDirection
    where: disasterDescriptive_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [disasterDescriptive!]!
  fundReleaseDescriptive(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): fundReleaseDescriptive
  fundReleaseDescriptives(
    skip: Int = 0
    first: Int = 100
    orderBy: fundReleaseDescriptive_orderBy
    orderDirection: OrderDirection
    where: fundReleaseDescriptive_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [fundReleaseDescriptive!]!
  kintoToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoToken
  kintoTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoToken_orderBy
    orderDirection: OrderDirection
    where: kintoToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoToken!]!
  kintoAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoAccount
  kintoAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoAccount_orderBy
    orderDirection: OrderDirection
    where: kintoAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoAccount!]!
  kintoBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoBalance
  kintoBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoBalance_orderBy
    orderDirection: OrderDirection
    where: kintoBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoBalance!]!
  kintoTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoTransfer
  kintoTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoTransfer_orderBy
    orderDirection: OrderDirection
    where: kintoTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoTransfer!]!
  kintoVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): kintoVault
  kintoVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: kintoVault_orderBy
    orderDirection: OrderDirection
    where: kintoVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [kintoVault!]!
  polToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polToken
  polTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: polToken_orderBy
    orderDirection: OrderDirection
    where: polToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polToken!]!
  polAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polAccount
  polAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polAccount_orderBy
    orderDirection: OrderDirection
    where: polAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polAccount!]!
  polBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polBalance
  polBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polBalance_orderBy
    orderDirection: OrderDirection
    where: polBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polBalance!]!
  polTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polTransfer
  polTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polTransfer_orderBy
    orderDirection: OrderDirection
    where: polTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polTransfer!]!
  polVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polVault
  polVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: polVault_orderBy
    orderDirection: OrderDirection
    where: polVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polVault!]!
  ethToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethToken
  ethTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: ethToken_orderBy
    orderDirection: OrderDirection
    where: ethToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethToken!]!
  ethAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethAccount
  ethAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: ethAccount_orderBy
    orderDirection: OrderDirection
    where: ethAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethAccount!]!
  ethBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethBalance
  ethBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: ethBalance_orderBy
    orderDirection: OrderDirection
    where: ethBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethBalance!]!
  ethTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethTransfer
  ethTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: ethTransfer_orderBy
    orderDirection: OrderDirection
    where: ethTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethTransfer!]!
  ethVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ethVault
  ethVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: ethVault_orderBy
    orderDirection: OrderDirection
    where: ethVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ethVault!]!
  baseToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseToken
  baseTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: baseToken_orderBy
    orderDirection: OrderDirection
    where: baseToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseToken!]!
  baseAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseAccount
  baseAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: baseAccount_orderBy
    orderDirection: OrderDirection
    where: baseAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseAccount!]!
  baseBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseBalance
  baseBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: baseBalance_orderBy
    orderDirection: OrderDirection
    where: baseBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseBalance!]!
  baseTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseTransfer
  baseTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: baseTransfer_orderBy
    orderDirection: OrderDirection
    where: baseTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseTransfer!]!
  baseVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): baseVault
  baseVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: baseVault_orderBy
    orderDirection: OrderDirection
    where: baseVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [baseVault!]!
  scrollToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollToken
  scrollTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollToken_orderBy
    orderDirection: OrderDirection
    where: scrollToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollToken!]!
  scrollAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollAccount
  scrollAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollAccount_orderBy
    orderDirection: OrderDirection
    where: scrollAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollAccount!]!
  scrollBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollBalance
  scrollBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollBalance_orderBy
    orderDirection: OrderDirection
    where: scrollBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollBalance!]!
  scrollTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollTransfer
  scrollTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollTransfer_orderBy
    orderDirection: OrderDirection
    where: scrollTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollTransfer!]!
  scrollVault(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): scrollVault
  scrollVaults(
    skip: Int = 0
    first: Int = 100
    orderBy: scrollVault_orderBy
    orderDirection: OrderDirection
    where: scrollVault_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [scrollVault!]!
}

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

"""
8 bytes signed integer

"""
scalar Int8

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

type beneficiary {
  """the beneficiary address"""
  id: ID!
  """fundings received by this beneficiary"""
  fundings(skip: Int = 0, first: Int = 100, orderBy: funding_orderBy, orderDirection: OrderDirection, where: funding_filter): [funding!]!
  """total funding amount received in USD"""
  totalReceivedAmount: BigInt!
  """total number of fundings received"""
  totalFundingsReceived: BigInt!
  """total number of claims initiated"""
  totalClaimsInitiated: BigInt!
  """name of the beneficiary organization"""
  name: String!
  """all fund releases received by this beneficiary"""
  receivedFunds(skip: Int = 0, first: Int = 100, orderBy: fundReleaseDescriptive_orderBy, orderDirection: OrderDirection, where: fundReleaseDescriptive_filter): [fundReleaseDescriptive!]!
  """total amount received across all disasters"""
  totalAmountReceived: BigInt!
  """total number of fund releases received"""
  totalFundReleases: BigInt!
  """disasters for which beneficiary received funds"""
  disasters(skip: Int = 0, first: Int = 100, orderBy: disasterDescriptive_orderBy, orderDirection: OrderDirection, where: disasterDescriptive_filter): [disasterDescriptive!]!
}

input beneficiary_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  fundings_: funding_filter
  totalReceivedAmount: BigInt
  totalReceivedAmount_not: BigInt
  totalReceivedAmount_gt: BigInt
  totalReceivedAmount_lt: BigInt
  totalReceivedAmount_gte: BigInt
  totalReceivedAmount_lte: BigInt
  totalReceivedAmount_in: [BigInt!]
  totalReceivedAmount_not_in: [BigInt!]
  totalFundingsReceived: BigInt
  totalFundingsReceived_not: BigInt
  totalFundingsReceived_gt: BigInt
  totalFundingsReceived_lt: BigInt
  totalFundingsReceived_gte: BigInt
  totalFundingsReceived_lte: BigInt
  totalFundingsReceived_in: [BigInt!]
  totalFundingsReceived_not_in: [BigInt!]
  totalClaimsInitiated: BigInt
  totalClaimsInitiated_not: BigInt
  totalClaimsInitiated_gt: BigInt
  totalClaimsInitiated_lt: BigInt
  totalClaimsInitiated_gte: BigInt
  totalClaimsInitiated_lte: BigInt
  totalClaimsInitiated_in: [BigInt!]
  totalClaimsInitiated_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [beneficiary_filter]
  or: [beneficiary_filter]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  receivedFunds_: fundReleaseDescriptive_filter
  totalAmountReceived: BigInt
  totalAmountReceived_not: BigInt
  totalAmountReceived_gt: BigInt
  totalAmountReceived_lt: BigInt
  totalAmountReceived_gte: BigInt
  totalAmountReceived_lte: BigInt
  totalAmountReceived_in: [BigInt!]
  totalAmountReceived_not_in: [BigInt!]
  totalFundReleases: BigInt
  totalFundReleases_not: BigInt
  totalFundReleases_gt: BigInt
  totalFundReleases_lt: BigInt
  totalFundReleases_gte: BigInt
  totalFundReleases_lte: BigInt
  totalFundReleases_in: [BigInt!]
  totalFundReleases_not_in: [BigInt!]
  disasters: [String!]
  disasters_not: [String!]
  disasters_contains: [String!]
  disasters_contains_nocase: [String!]
  disasters_not_contains: [String!]
  disasters_not_contains_nocase: [String!]
  disasters_: disasterDescriptive_filter
}

enum beneficiary_orderBy {
  id
  fundings
  totalReceivedAmount
  totalFundingsReceived
  totalClaimsInitiated
  name
  receivedFunds
  totalAmountReceived
  totalFundReleases
  disasters
}

type claim {
  """fund release id + chain id"""
  id: ID!
  """the funding this claim belongs to"""
  funding: funding!
  """chain id where claim was made"""
  chainId: BigInt!
  """amounts claimed for each token"""
  amounts: [BigInt!]!
  """transaction hash of claim initiation"""
  transactionHash: Bytes!
  """fund release associated with this claim"""
  fundReleaseDescriptive: fundReleaseDescriptive!
  """tokens claimed (0: Native, 1: WETH, 2: USDC, 3: USDT)"""
  tokens: [Int!]!
}

input claim_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  funding: String
  funding_not: String
  funding_gt: String
  funding_lt: String
  funding_gte: String
  funding_lte: String
  funding_in: [String!]
  funding_not_in: [String!]
  funding_contains: String
  funding_contains_nocase: String
  funding_not_contains: String
  funding_not_contains_nocase: String
  funding_starts_with: String
  funding_starts_with_nocase: String
  funding_not_starts_with: String
  funding_not_starts_with_nocase: String
  funding_ends_with: String
  funding_ends_with_nocase: String
  funding_not_ends_with: String
  funding_not_ends_with_nocase: String
  funding_: funding_filter
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  amounts: [BigInt!]
  amounts_not: [BigInt!]
  amounts_contains: [BigInt!]
  amounts_contains_nocase: [BigInt!]
  amounts_not_contains: [BigInt!]
  amounts_not_contains_nocase: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [claim_filter]
  or: [claim_filter]
  fundReleaseDescriptive: String
  fundReleaseDescriptive_not: String
  fundReleaseDescriptive_gt: String
  fundReleaseDescriptive_lt: String
  fundReleaseDescriptive_gte: String
  fundReleaseDescriptive_lte: String
  fundReleaseDescriptive_in: [String!]
  fundReleaseDescriptive_not_in: [String!]
  fundReleaseDescriptive_contains: String
  fundReleaseDescriptive_contains_nocase: String
  fundReleaseDescriptive_not_contains: String
  fundReleaseDescriptive_not_contains_nocase: String
  fundReleaseDescriptive_starts_with: String
  fundReleaseDescriptive_starts_with_nocase: String
  fundReleaseDescriptive_not_starts_with: String
  fundReleaseDescriptive_not_starts_with_nocase: String
  fundReleaseDescriptive_ends_with: String
  fundReleaseDescriptive_ends_with_nocase: String
  fundReleaseDescriptive_not_ends_with: String
  fundReleaseDescriptive_not_ends_with_nocase: String
  fundReleaseDescriptive_: fundReleaseDescriptive_filter
  tokens: [Int!]
  tokens_not: [Int!]
  tokens_contains: [Int!]
  tokens_contains_nocase: [Int!]
  tokens_not_contains: [Int!]
  tokens_not_contains_nocase: [Int!]
}

enum claim_orderBy {
  id
  funding
  funding__id
  funding__amountInUSD
  funding__claimed
  funding__attestationId
  funding__transactionHash
  chainId
  amounts
  transactionHash
  fundReleaseDescriptive
  fundReleaseDescriptive__id
  fundReleaseDescriptive__attestationId
  fundReleaseDescriptive__comments
  fundReleaseDescriptive__amountInUSD
  fundReleaseDescriptive__hyperlaneMessageId
  fundReleaseDescriptive__transactionHash
  tokens
}

type disaster {
  """the disaster id"""
  id: ID!
  """attestation id for the disaster"""
  attestationId: String!
  """vault address created for the disaster"""
  vaultAddress: Bytes!
  """estimated requirement in USD"""
  estimatedRequirementInUSD: BigInt!
  """all fundings allocated for this disaster"""
  fundings(skip: Int = 0, first: Int = 100, orderBy: funding_orderBy, orderDirection: OrderDirection, where: funding_filter): [funding!]!
  """total funding amount allocated in USD"""
  totalFundingAmount: BigInt!
  """total number of beneficiaries"""
  totalBeneficiaries: BigInt!
  """transaction hash of disaster creation"""
  transactionHash: Bytes!
}

input disaster_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  attestationId: String
  attestationId_not: String
  attestationId_gt: String
  attestationId_lt: String
  attestationId_gte: String
  attestationId_lte: String
  attestationId_in: [String!]
  attestationId_not_in: [String!]
  attestationId_contains: String
  attestationId_contains_nocase: String
  attestationId_not_contains: String
  attestationId_not_contains_nocase: String
  attestationId_starts_with: String
  attestationId_starts_with_nocase: String
  attestationId_not_starts_with: String
  attestationId_not_starts_with_nocase: String
  attestationId_ends_with: String
  attestationId_ends_with_nocase: String
  attestationId_not_ends_with: String
  attestationId_not_ends_with_nocase: String
  vaultAddress: Bytes
  vaultAddress_not: Bytes
  vaultAddress_gt: Bytes
  vaultAddress_lt: Bytes
  vaultAddress_gte: Bytes
  vaultAddress_lte: Bytes
  vaultAddress_in: [Bytes!]
  vaultAddress_not_in: [Bytes!]
  vaultAddress_contains: Bytes
  vaultAddress_not_contains: Bytes
  estimatedRequirementInUSD: BigInt
  estimatedRequirementInUSD_not: BigInt
  estimatedRequirementInUSD_gt: BigInt
  estimatedRequirementInUSD_lt: BigInt
  estimatedRequirementInUSD_gte: BigInt
  estimatedRequirementInUSD_lte: BigInt
  estimatedRequirementInUSD_in: [BigInt!]
  estimatedRequirementInUSD_not_in: [BigInt!]
  fundings_: funding_filter
  totalFundingAmount: BigInt
  totalFundingAmount_not: BigInt
  totalFundingAmount_gt: BigInt
  totalFundingAmount_lt: BigInt
  totalFundingAmount_gte: BigInt
  totalFundingAmount_lte: BigInt
  totalFundingAmount_in: [BigInt!]
  totalFundingAmount_not_in: [BigInt!]
  totalBeneficiaries: BigInt
  totalBeneficiaries_not: BigInt
  totalBeneficiaries_gt: BigInt
  totalBeneficiaries_lt: BigInt
  totalBeneficiaries_gte: BigInt
  totalBeneficiaries_lte: BigInt
  totalBeneficiaries_in: [BigInt!]
  totalBeneficiaries_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [disaster_filter]
  or: [disaster_filter]
}

enum disaster_orderBy {
  id
  attestationId
  vaultAddress
  estimatedRequirementInUSD
  fundings
  totalFundingAmount
  totalBeneficiaries
  transactionHash
}

type funding {
  """funding id"""
  id: ID!
  """the disaster this funding belongs to"""
  disaster: disaster!
  """the beneficiary receiving the funding"""
  beneficiary: beneficiary!
  """array of claims across chains"""
  claims(skip: Int = 0, first: Int = 100, orderBy: claim_orderBy, orderDirection: OrderDirection, where: claim_filter): [claim!]!
  """total funding amount in USD"""
  amountInUSD: BigInt!
  """whether funding has been claimed"""
  claimed: Boolean!
  """attestation id for funding approval"""
  attestationId: String!
  """transaction hash of funding unlock"""
  transactionHash: Bytes!
}

input funding_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  disaster: String
  disaster_not: String
  disaster_gt: String
  disaster_lt: String
  disaster_gte: String
  disaster_lte: String
  disaster_in: [String!]
  disaster_not_in: [String!]
  disaster_contains: String
  disaster_contains_nocase: String
  disaster_not_contains: String
  disaster_not_contains_nocase: String
  disaster_starts_with: String
  disaster_starts_with_nocase: String
  disaster_not_starts_with: String
  disaster_not_starts_with_nocase: String
  disaster_ends_with: String
  disaster_ends_with_nocase: String
  disaster_not_ends_with: String
  disaster_not_ends_with_nocase: String
  disaster_: disaster_filter
  beneficiary: String
  beneficiary_not: String
  beneficiary_gt: String
  beneficiary_lt: String
  beneficiary_gte: String
  beneficiary_lte: String
  beneficiary_in: [String!]
  beneficiary_not_in: [String!]
  beneficiary_contains: String
  beneficiary_contains_nocase: String
  beneficiary_not_contains: String
  beneficiary_not_contains_nocase: String
  beneficiary_starts_with: String
  beneficiary_starts_with_nocase: String
  beneficiary_not_starts_with: String
  beneficiary_not_starts_with_nocase: String
  beneficiary_ends_with: String
  beneficiary_ends_with_nocase: String
  beneficiary_not_ends_with: String
  beneficiary_not_ends_with_nocase: String
  beneficiary_: beneficiary_filter
  claims_: claim_filter
  amountInUSD: BigInt
  amountInUSD_not: BigInt
  amountInUSD_gt: BigInt
  amountInUSD_lt: BigInt
  amountInUSD_gte: BigInt
  amountInUSD_lte: BigInt
  amountInUSD_in: [BigInt!]
  amountInUSD_not_in: [BigInt!]
  claimed: Boolean
  claimed_not: Boolean
  claimed_in: [Boolean!]
  claimed_not_in: [Boolean!]
  attestationId: String
  attestationId_not: String
  attestationId_gt: String
  attestationId_lt: String
  attestationId_gte: String
  attestationId_lte: String
  attestationId_in: [String!]
  attestationId_not_in: [String!]
  attestationId_contains: String
  attestationId_contains_nocase: String
  attestationId_not_contains: String
  attestationId_not_contains_nocase: String
  attestationId_starts_with: String
  attestationId_starts_with_nocase: String
  attestationId_not_starts_with: String
  attestationId_not_starts_with_nocase: String
  attestationId_ends_with: String
  attestationId_ends_with_nocase: String
  attestationId_not_ends_with: String
  attestationId_not_ends_with_nocase: String
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [funding_filter]
  or: [funding_filter]
}

enum funding_orderBy {
  id
  disaster
  disaster__id
  disaster__attestationId
  disaster__vaultAddress
  disaster__estimatedRequirementInUSD
  disaster__totalFundingAmount
  disaster__totalBeneficiaries
  disaster__transactionHash
  beneficiary
  beneficiary__id
  beneficiary__totalReceivedAmount
  beneficiary__totalFundingsReceived
  beneficiary__totalClaimsInitiated
  claims
  amountInUSD
  claimed
  attestationId
  transactionHash
}

type disasterDescriptive {
  """the id of the disaster"""
  id: ID!
  """name of the disaster"""
  name: String!
  """description of the disaster"""
  description: String!
  """type of disaster (earthquake, flood, etc.)"""
  disasterType: String!
  """location where disaster occurred"""
  location: String!
  """timestamp when disaster was created"""
  createdAt: BigInt!
  """total funds needed for disaster relief"""
  fundsNeeded: BigInt!
  """ENS name associated with the disaster"""
  ensName: String!
  """Base account name associated with the disaster"""
  baseName: String!
  """address of the vault created for this disaster"""
  vaultAddress: Bytes!
  """attestation id for this disaster creation"""
  attestationId: BigInt!
  """transaction hash in which disaster was created"""
  transactionHash: Bytes!
  """hyperlane message id for this disaster"""
  hyperlaneMessageId: Bytes!
  """all fund releases associated with this disaster"""
  fundReleases(skip: Int = 0, first: Int = 100, orderBy: fundReleaseDescriptive_orderBy, orderDirection: OrderDirection, where: fundReleaseDescriptive_filter): [fundReleaseDescriptive!]!
  """total funds released for this disaster"""
  totalFundsReleased: BigInt!
  """total number of beneficiaries who received funds"""
  totalBeneficiaries: BigInt!
}

input disasterDescriptive_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  disasterType: String
  disasterType_not: String
  disasterType_gt: String
  disasterType_lt: String
  disasterType_gte: String
  disasterType_lte: String
  disasterType_in: [String!]
  disasterType_not_in: [String!]
  disasterType_contains: String
  disasterType_contains_nocase: String
  disasterType_not_contains: String
  disasterType_not_contains_nocase: String
  disasterType_starts_with: String
  disasterType_starts_with_nocase: String
  disasterType_not_starts_with: String
  disasterType_not_starts_with_nocase: String
  disasterType_ends_with: String
  disasterType_ends_with_nocase: String
  disasterType_not_ends_with: String
  disasterType_not_ends_with_nocase: String
  location: String
  location_not: String
  location_gt: String
  location_lt: String
  location_gte: String
  location_lte: String
  location_in: [String!]
  location_not_in: [String!]
  location_contains: String
  location_contains_nocase: String
  location_not_contains: String
  location_not_contains_nocase: String
  location_starts_with: String
  location_starts_with_nocase: String
  location_not_starts_with: String
  location_not_starts_with_nocase: String
  location_ends_with: String
  location_ends_with_nocase: String
  location_not_ends_with: String
  location_not_ends_with_nocase: String
  createdAt: BigInt
  createdAt_not: BigInt
  createdAt_gt: BigInt
  createdAt_lt: BigInt
  createdAt_gte: BigInt
  createdAt_lte: BigInt
  createdAt_in: [BigInt!]
  createdAt_not_in: [BigInt!]
  fundsNeeded: BigInt
  fundsNeeded_not: BigInt
  fundsNeeded_gt: BigInt
  fundsNeeded_lt: BigInt
  fundsNeeded_gte: BigInt
  fundsNeeded_lte: BigInt
  fundsNeeded_in: [BigInt!]
  fundsNeeded_not_in: [BigInt!]
  ensName: String
  ensName_not: String
  ensName_gt: String
  ensName_lt: String
  ensName_gte: String
  ensName_lte: String
  ensName_in: [String!]
  ensName_not_in: [String!]
  ensName_contains: String
  ensName_contains_nocase: String
  ensName_not_contains: String
  ensName_not_contains_nocase: String
  ensName_starts_with: String
  ensName_starts_with_nocase: String
  ensName_not_starts_with: String
  ensName_not_starts_with_nocase: String
  ensName_ends_with: String
  ensName_ends_with_nocase: String
  ensName_not_ends_with: String
  ensName_not_ends_with_nocase: String
  baseName: String
  baseName_not: String
  baseName_gt: String
  baseName_lt: String
  baseName_gte: String
  baseName_lte: String
  baseName_in: [String!]
  baseName_not_in: [String!]
  baseName_contains: String
  baseName_contains_nocase: String
  baseName_not_contains: String
  baseName_not_contains_nocase: String
  baseName_starts_with: String
  baseName_starts_with_nocase: String
  baseName_not_starts_with: String
  baseName_not_starts_with_nocase: String
  baseName_ends_with: String
  baseName_ends_with_nocase: String
  baseName_not_ends_with: String
  baseName_not_ends_with_nocase: String
  vaultAddress: Bytes
  vaultAddress_not: Bytes
  vaultAddress_gt: Bytes
  vaultAddress_lt: Bytes
  vaultAddress_gte: Bytes
  vaultAddress_lte: Bytes
  vaultAddress_in: [Bytes!]
  vaultAddress_not_in: [Bytes!]
  vaultAddress_contains: Bytes
  vaultAddress_not_contains: Bytes
  attestationId: BigInt
  attestationId_not: BigInt
  attestationId_gt: BigInt
  attestationId_lt: BigInt
  attestationId_gte: BigInt
  attestationId_lte: BigInt
  attestationId_in: [BigInt!]
  attestationId_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  hyperlaneMessageId: Bytes
  hyperlaneMessageId_not: Bytes
  hyperlaneMessageId_gt: Bytes
  hyperlaneMessageId_lt: Bytes
  hyperlaneMessageId_gte: Bytes
  hyperlaneMessageId_lte: Bytes
  hyperlaneMessageId_in: [Bytes!]
  hyperlaneMessageId_not_in: [Bytes!]
  hyperlaneMessageId_contains: Bytes
  hyperlaneMessageId_not_contains: Bytes
  fundReleases_: fundReleaseDescriptive_filter
  totalFundsReleased: BigInt
  totalFundsReleased_not: BigInt
  totalFundsReleased_gt: BigInt
  totalFundsReleased_lt: BigInt
  totalFundsReleased_gte: BigInt
  totalFundsReleased_lte: BigInt
  totalFundsReleased_in: [BigInt!]
  totalFundsReleased_not_in: [BigInt!]
  totalBeneficiaries: BigInt
  totalBeneficiaries_not: BigInt
  totalBeneficiaries_gt: BigInt
  totalBeneficiaries_lt: BigInt
  totalBeneficiaries_gte: BigInt
  totalBeneficiaries_lte: BigInt
  totalBeneficiaries_in: [BigInt!]
  totalBeneficiaries_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [disasterDescriptive_filter]
  or: [disasterDescriptive_filter]
}

enum disasterDescriptive_orderBy {
  id
  name
  description
  disasterType
  location
  createdAt
  fundsNeeded
  ensName
  baseName
  vaultAddress
  attestationId
  transactionHash
  hyperlaneMessageId
  fundReleases
  totalFundsReleased
  totalBeneficiaries
}

type fundReleaseDescriptive {
  """disaster id + beneficiary address + attestation id"""
  id: ID!
  """disaster associated with this fund release"""
  disaster: disasterDescriptive!
  """beneficiary who received the funds"""
  beneficiary: beneficiary!
  """attestation id for this fund release"""
  attestationId: BigInt!
  """comments provided during fund release"""
  comments: String!
  """total USD amount released"""
  amountInUSD: BigInt!
  """hyperlane message id for this fund claim"""
  hyperlaneMessageId: Bytes!
  """claims made across different chains"""
  claims(skip: Int = 0, first: Int = 100, orderBy: claim_orderBy, orderDirection: OrderDirection, where: claim_filter): [claim!]!
  """transaction hash in which funds were released"""
  transactionHash: Bytes!
}

input fundReleaseDescriptive_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  disaster: String
  disaster_not: String
  disaster_gt: String
  disaster_lt: String
  disaster_gte: String
  disaster_lte: String
  disaster_in: [String!]
  disaster_not_in: [String!]
  disaster_contains: String
  disaster_contains_nocase: String
  disaster_not_contains: String
  disaster_not_contains_nocase: String
  disaster_starts_with: String
  disaster_starts_with_nocase: String
  disaster_not_starts_with: String
  disaster_not_starts_with_nocase: String
  disaster_ends_with: String
  disaster_ends_with_nocase: String
  disaster_not_ends_with: String
  disaster_not_ends_with_nocase: String
  disaster_: disasterDescriptive_filter
  beneficiary: String
  beneficiary_not: String
  beneficiary_gt: String
  beneficiary_lt: String
  beneficiary_gte: String
  beneficiary_lte: String
  beneficiary_in: [String!]
  beneficiary_not_in: [String!]
  beneficiary_contains: String
  beneficiary_contains_nocase: String
  beneficiary_not_contains: String
  beneficiary_not_contains_nocase: String
  beneficiary_starts_with: String
  beneficiary_starts_with_nocase: String
  beneficiary_not_starts_with: String
  beneficiary_not_starts_with_nocase: String
  beneficiary_ends_with: String
  beneficiary_ends_with_nocase: String
  beneficiary_not_ends_with: String
  beneficiary_not_ends_with_nocase: String
  beneficiary_: beneficiary_filter
  attestationId: BigInt
  attestationId_not: BigInt
  attestationId_gt: BigInt
  attestationId_lt: BigInt
  attestationId_gte: BigInt
  attestationId_lte: BigInt
  attestationId_in: [BigInt!]
  attestationId_not_in: [BigInt!]
  comments: String
  comments_not: String
  comments_gt: String
  comments_lt: String
  comments_gte: String
  comments_lte: String
  comments_in: [String!]
  comments_not_in: [String!]
  comments_contains: String
  comments_contains_nocase: String
  comments_not_contains: String
  comments_not_contains_nocase: String
  comments_starts_with: String
  comments_starts_with_nocase: String
  comments_not_starts_with: String
  comments_not_starts_with_nocase: String
  comments_ends_with: String
  comments_ends_with_nocase: String
  comments_not_ends_with: String
  comments_not_ends_with_nocase: String
  amountInUSD: BigInt
  amountInUSD_not: BigInt
  amountInUSD_gt: BigInt
  amountInUSD_lt: BigInt
  amountInUSD_gte: BigInt
  amountInUSD_lte: BigInt
  amountInUSD_in: [BigInt!]
  amountInUSD_not_in: [BigInt!]
  hyperlaneMessageId: Bytes
  hyperlaneMessageId_not: Bytes
  hyperlaneMessageId_gt: Bytes
  hyperlaneMessageId_lt: Bytes
  hyperlaneMessageId_gte: Bytes
  hyperlaneMessageId_lte: Bytes
  hyperlaneMessageId_in: [Bytes!]
  hyperlaneMessageId_not_in: [Bytes!]
  hyperlaneMessageId_contains: Bytes
  hyperlaneMessageId_not_contains: Bytes
  claims_: claim_filter
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [fundReleaseDescriptive_filter]
  or: [fundReleaseDescriptive_filter]
}

enum fundReleaseDescriptive_orderBy {
  id
  disaster
  disaster__id
  disaster__name
  disaster__description
  disaster__disasterType
  disaster__location
  disaster__createdAt
  disaster__fundsNeeded
  disaster__ensName
  disaster__baseName
  disaster__vaultAddress
  disaster__attestationId
  disaster__transactionHash
  disaster__hyperlaneMessageId
  disaster__totalFundsReleased
  disaster__totalBeneficiaries
  beneficiary
  beneficiary__id
  beneficiary__name
  beneficiary__totalAmountReceived
  beneficiary__totalFundReleases
  attestationId
  comments
  amountInUSD
  hyperlaneMessageId
  claims
  transactionHash
}

type kintoAccount {
  """account address"""
  id: ID!
  """transfers where this account is the sender"""
  transfersOut(skip: Int = 0, first: Int = 100, orderBy: kintoTransfer_orderBy, orderDirection: OrderDirection, where: kintoTransfer_filter): [kintoTransfer!]!
  """transfers where this account is the receiver"""
  transfersIn(skip: Int = 0, first: Int = 100, orderBy: kintoTransfer_orderBy, orderDirection: OrderDirection, where: kintoTransfer_filter): [kintoTransfer!]!
  """balances for each kintoToken"""
  balances(skip: Int = 0, first: Int = 100, orderBy: kintoBalance_orderBy, orderDirection: OrderDirection, where: kintoBalance_filter): [kintoBalance!]!
}

input kintoAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfersOut_: kintoTransfer_filter
  transfersIn_: kintoTransfer_filter
  balances_: kintoBalance_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [kintoAccount_filter]
  or: [kintoAccount_filter]
}

enum kintoAccount_orderBy {
  id
  transfersOut
  transfersIn
  balances
}

type kintoBalance {
  """account address + kintoToken address"""
  id: ID!
  """the account that holds the balance"""
  account: kintoAccount!
  """the kintoToken"""
  token: kintoToken!
  """the vault if this balance belongs to one"""
  vault: kintoVault
  """current balance"""
  amount: BigInt!
  """block number of last update"""
  lastUpdateBlock: BigInt!
  """timestamp of last update"""
  lastUpdateTimestamp: BigInt!
}

input kintoBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: kintoAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: kintoToken_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: kintoVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lastUpdateBlock: BigInt
  lastUpdateBlock_not: BigInt
  lastUpdateBlock_gt: BigInt
  lastUpdateBlock_lt: BigInt
  lastUpdateBlock_gte: BigInt
  lastUpdateBlock_lte: BigInt
  lastUpdateBlock_in: [BigInt!]
  lastUpdateBlock_not_in: [BigInt!]
  lastUpdateTimestamp: BigInt
  lastUpdateTimestamp_not: BigInt
  lastUpdateTimestamp_gt: BigInt
  lastUpdateTimestamp_lt: BigInt
  lastUpdateTimestamp_gte: BigInt
  lastUpdateTimestamp_lte: BigInt
  lastUpdateTimestamp_in: [BigInt!]
  lastUpdateTimestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [kintoBalance_filter]
  or: [kintoBalance_filter]
}

enum kintoBalance_orderBy {
  id
  account
  account__id
  token
  token__id
  token__name
  token__symbol
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  lastUpdateBlock
  lastUpdateTimestamp
}

type kintoToken {
  """kintoToken contract address"""
  id: ID!
  """kintoToken name"""
  name: String!
  """kintoToken symbol"""
  symbol: String!
  """all transfers of this kintoToken"""
  transfers(skip: Int = 0, first: Int = 100, orderBy: kintoTransfer_orderBy, orderDirection: OrderDirection, where: kintoTransfer_filter): [kintoTransfer!]!
}

input kintoToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  transfers_: kintoTransfer_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [kintoToken_filter]
  or: [kintoToken_filter]
}

enum kintoToken_orderBy {
  id
  name
  symbol
  transfers
}

type kintoTransfer {
  """transaction hash + log index"""
  id: ID!
  """the kintoToken being transferred"""
  token: kintoToken!
  """sender address"""
  from: kintoAccount!
  """receiver address"""
  to: kintoAccount!
  """vault if this is a vault deposit"""
  vault: kintoVault
  """amount transferred"""
  amount: BigInt!
  """block number"""
  blockNumber: BigInt!
  """block timestamp"""
  timestamp: BigInt!
  """transaction hash"""
  transactionHash: Bytes!
}

input kintoTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: kintoToken_filter
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: kintoAccount_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: kintoAccount_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: kintoVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [kintoTransfer_filter]
  or: [kintoTransfer_filter]
}

enum kintoTransfer_orderBy {
  id
  token
  token__id
  token__name
  token__symbol
  from
  from__id
  to
  to__id
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  blockNumber
  timestamp
  transactionHash
}

type kintoVault {
  """vault address"""
  id: ID!
  """deposits received by this vault"""
  deposits(skip: Int = 0, first: Int = 100, orderBy: kintoTransfer_orderBy, orderDirection: OrderDirection, where: kintoTransfer_filter): [kintoTransfer!]!
  """total value locked in vault per kintoToken"""
  tokenBalances(skip: Int = 0, first: Int = 100, orderBy: kintoBalance_orderBy, orderDirection: OrderDirection, where: kintoBalance_filter): [kintoBalance!]!
  """total number of depositors"""
  totalDepositors: BigInt!
  """total value locked across all tokens"""
  totalValueLocked: BigInt!
}

input kintoVault_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  deposits_: kintoTransfer_filter
  tokenBalances_: kintoBalance_filter
  totalDepositors: BigInt
  totalDepositors_not: BigInt
  totalDepositors_gt: BigInt
  totalDepositors_lt: BigInt
  totalDepositors_gte: BigInt
  totalDepositors_lte: BigInt
  totalDepositors_in: [BigInt!]
  totalDepositors_not_in: [BigInt!]
  totalValueLocked: BigInt
  totalValueLocked_not: BigInt
  totalValueLocked_gt: BigInt
  totalValueLocked_lt: BigInt
  totalValueLocked_gte: BigInt
  totalValueLocked_lte: BigInt
  totalValueLocked_in: [BigInt!]
  totalValueLocked_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [kintoVault_filter]
  or: [kintoVault_filter]
}

enum kintoVault_orderBy {
  id
  deposits
  tokenBalances
  totalDepositors
  totalValueLocked
}

type polAccount {
  """polAccount address"""
  id: ID!
  """transfers where this polAccount is the sender"""
  transfersOut(skip: Int = 0, first: Int = 100, orderBy: polTransfer_orderBy, orderDirection: OrderDirection, where: polTransfer_filter): [polTransfer!]!
  """transfers where this polAccount is the receiver"""
  transfersIn(skip: Int = 0, first: Int = 100, orderBy: polTransfer_orderBy, orderDirection: OrderDirection, where: polTransfer_filter): [polTransfer!]!
  """balances for each polToken"""
  balances(skip: Int = 0, first: Int = 100, orderBy: polBalance_orderBy, orderDirection: OrderDirection, where: polBalance_filter): [polBalance!]!
}

input polAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfersOut_: polTransfer_filter
  transfersIn_: polTransfer_filter
  balances_: polBalance_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [polAccount_filter]
  or: [polAccount_filter]
}

enum polAccount_orderBy {
  id
  transfersOut
  transfersIn
  balances
}

type polBalance {
  """polAccount address + polToken address"""
  id: ID!
  """the polAccount that holds the polBalance"""
  account: polAccount!
  """the polToken"""
  token: polToken!
  """the polVault if this polBalance belongs to one"""
  vault: polVault
  """current polBalance"""
  amount: BigInt!
  """block number of last update"""
  lastUpdateBlock: BigInt!
  """timestamp of last update"""
  lastUpdateTimestamp: BigInt!
}

input polBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: polAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: polToken_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: polVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lastUpdateBlock: BigInt
  lastUpdateBlock_not: BigInt
  lastUpdateBlock_gt: BigInt
  lastUpdateBlock_lt: BigInt
  lastUpdateBlock_gte: BigInt
  lastUpdateBlock_lte: BigInt
  lastUpdateBlock_in: [BigInt!]
  lastUpdateBlock_not_in: [BigInt!]
  lastUpdateTimestamp: BigInt
  lastUpdateTimestamp_not: BigInt
  lastUpdateTimestamp_gt: BigInt
  lastUpdateTimestamp_lt: BigInt
  lastUpdateTimestamp_gte: BigInt
  lastUpdateTimestamp_lte: BigInt
  lastUpdateTimestamp_in: [BigInt!]
  lastUpdateTimestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [polBalance_filter]
  or: [polBalance_filter]
}

enum polBalance_orderBy {
  id
  account
  account__id
  token
  token__id
  token__name
  token__symbol
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  lastUpdateBlock
  lastUpdateTimestamp
}

type polToken {
  """polToken contract address"""
  id: ID!
  """polToken name"""
  name: String!
  """polToken symbol"""
  symbol: String!
  """all transfers of this polToken"""
  transfers(skip: Int = 0, first: Int = 100, orderBy: polTransfer_orderBy, orderDirection: OrderDirection, where: polTransfer_filter): [polTransfer!]!
}

input polToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  transfers_: polTransfer_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [polToken_filter]
  or: [polToken_filter]
}

enum polToken_orderBy {
  id
  name
  symbol
  transfers
}

type polTransfer {
  """transaction hash + log index"""
  id: ID!
  """the polToken being transferred"""
  token: polToken!
  """sender address"""
  from: polAccount!
  """receiver address"""
  to: polAccount!
  """polVault if this is a polVault deposit"""
  vault: polVault
  """amount transferred"""
  amount: BigInt!
  """block number"""
  blockNumber: BigInt!
  """block timestamp"""
  timestamp: BigInt!
  """transaction hash"""
  transactionHash: Bytes!
}

input polTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: polToken_filter
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: polAccount_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: polAccount_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: polVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [polTransfer_filter]
  or: [polTransfer_filter]
}

enum polTransfer_orderBy {
  id
  token
  token__id
  token__name
  token__symbol
  from
  from__id
  to
  to__id
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  blockNumber
  timestamp
  transactionHash
}

type polVault {
  """polVault address"""
  id: ID!
  """deposits received by this polVault"""
  deposits(skip: Int = 0, first: Int = 100, orderBy: polTransfer_orderBy, orderDirection: OrderDirection, where: polTransfer_filter): [polTransfer!]!
  """total value locked in polVault per polToken"""
  tokenBalances(skip: Int = 0, first: Int = 100, orderBy: polBalance_orderBy, orderDirection: OrderDirection, where: polBalance_filter): [polBalance!]!
  """total number of depositors"""
  totalDepositors: BigInt!
  """total value locked across all tokens"""
  totalValueLocked: BigInt!
}

input polVault_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  deposits_: polTransfer_filter
  tokenBalances_: polBalance_filter
  totalDepositors: BigInt
  totalDepositors_not: BigInt
  totalDepositors_gt: BigInt
  totalDepositors_lt: BigInt
  totalDepositors_gte: BigInt
  totalDepositors_lte: BigInt
  totalDepositors_in: [BigInt!]
  totalDepositors_not_in: [BigInt!]
  totalValueLocked: BigInt
  totalValueLocked_not: BigInt
  totalValueLocked_gt: BigInt
  totalValueLocked_lt: BigInt
  totalValueLocked_gte: BigInt
  totalValueLocked_lte: BigInt
  totalValueLocked_in: [BigInt!]
  totalValueLocked_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [polVault_filter]
  or: [polVault_filter]
}

enum polVault_orderBy {
  id
  deposits
  tokenBalances
  totalDepositors
  totalValueLocked
}

type ethAccount {
  """account address"""
  id: ID!
  """transfers where this account is the sender"""
  transfersOut(skip: Int = 0, first: Int = 100, orderBy: ethTransfer_orderBy, orderDirection: OrderDirection, where: ethTransfer_filter): [ethTransfer!]!
  """transfers where this account is the receiver"""
  transfersIn(skip: Int = 0, first: Int = 100, orderBy: ethTransfer_orderBy, orderDirection: OrderDirection, where: ethTransfer_filter): [ethTransfer!]!
  """balances for each ethToken"""
  balances(skip: Int = 0, first: Int = 100, orderBy: ethBalance_orderBy, orderDirection: OrderDirection, where: ethBalance_filter): [ethBalance!]!
}

input ethAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfersOut_: ethTransfer_filter
  transfersIn_: ethTransfer_filter
  balances_: ethBalance_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ethAccount_filter]
  or: [ethAccount_filter]
}

enum ethAccount_orderBy {
  id
  transfersOut
  transfersIn
  balances
}

type ethBalance {
  """account address + ethToken address"""
  id: ID!
  """the account that holds the balance"""
  account: ethAccount!
  """the token"""
  token: ethToken!
  """the vault if this balance belongs to one"""
  vault: ethVault
  """current balance"""
  amount: BigInt!
  """block number of last update"""
  lastUpdateBlock: BigInt!
  """timestamp of last update"""
  lastUpdateTimestamp: BigInt!
}

input ethBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: ethAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: ethToken_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: ethVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lastUpdateBlock: BigInt
  lastUpdateBlock_not: BigInt
  lastUpdateBlock_gt: BigInt
  lastUpdateBlock_lt: BigInt
  lastUpdateBlock_gte: BigInt
  lastUpdateBlock_lte: BigInt
  lastUpdateBlock_in: [BigInt!]
  lastUpdateBlock_not_in: [BigInt!]
  lastUpdateTimestamp: BigInt
  lastUpdateTimestamp_not: BigInt
  lastUpdateTimestamp_gt: BigInt
  lastUpdateTimestamp_lt: BigInt
  lastUpdateTimestamp_gte: BigInt
  lastUpdateTimestamp_lte: BigInt
  lastUpdateTimestamp_in: [BigInt!]
  lastUpdateTimestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ethBalance_filter]
  or: [ethBalance_filter]
}

enum ethBalance_orderBy {
  id
  account
  account__id
  token
  token__id
  token__name
  token__symbol
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  lastUpdateBlock
  lastUpdateTimestamp
}

type ethToken {
  """ethToken contract address"""
  id: ID!
  """ethToken name"""
  name: String!
  """ethToken symbol"""
  symbol: String!
  """all transfers of this ethToken"""
  transfers(skip: Int = 0, first: Int = 100, orderBy: ethTransfer_orderBy, orderDirection: OrderDirection, where: ethTransfer_filter): [ethTransfer!]!
}

input ethToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  transfers_: ethTransfer_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ethToken_filter]
  or: [ethToken_filter]
}

enum ethToken_orderBy {
  id
  name
  symbol
  transfers
}

type ethTransfer {
  """transaction hash + log index"""
  id: ID!
  """the ethToken being transferred"""
  token: ethToken!
  """sender address"""
  from: ethAccount!
  """receiver address"""
  to: ethAccount!
  """vault if this is a vault deposit"""
  vault: ethVault
  """amount transferred"""
  amount: BigInt!
  """block number"""
  blockNumber: BigInt!
  """block timestamp"""
  timestamp: BigInt!
  """transaction hash"""
  transactionHash: Bytes!
}

input ethTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: ethToken_filter
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: ethAccount_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: ethAccount_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: ethVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ethTransfer_filter]
  or: [ethTransfer_filter]
}

enum ethTransfer_orderBy {
  id
  token
  token__id
  token__name
  token__symbol
  from
  from__id
  to
  to__id
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  blockNumber
  timestamp
  transactionHash
}

type ethVault {
  """vault address"""
  id: ID!
  """deposits received by this vault"""
  deposits(skip: Int = 0, first: Int = 100, orderBy: ethTransfer_orderBy, orderDirection: OrderDirection, where: ethTransfer_filter): [ethTransfer!]!
  """total value locked in vault per ethToken"""
  tokenBalances(skip: Int = 0, first: Int = 100, orderBy: ethBalance_orderBy, orderDirection: OrderDirection, where: ethBalance_filter): [ethBalance!]!
  """total number of depositors"""
  totalDepositors: BigInt!
  """total value locked across all tokens"""
  totalValueLocked: BigInt!
}

input ethVault_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  deposits_: ethTransfer_filter
  tokenBalances_: ethBalance_filter
  totalDepositors: BigInt
  totalDepositors_not: BigInt
  totalDepositors_gt: BigInt
  totalDepositors_lt: BigInt
  totalDepositors_gte: BigInt
  totalDepositors_lte: BigInt
  totalDepositors_in: [BigInt!]
  totalDepositors_not_in: [BigInt!]
  totalValueLocked: BigInt
  totalValueLocked_not: BigInt
  totalValueLocked_gt: BigInt
  totalValueLocked_lt: BigInt
  totalValueLocked_gte: BigInt
  totalValueLocked_lte: BigInt
  totalValueLocked_in: [BigInt!]
  totalValueLocked_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ethVault_filter]
  or: [ethVault_filter]
}

enum ethVault_orderBy {
  id
  deposits
  tokenBalances
  totalDepositors
  totalValueLocked
}

type baseAccount {
  """account address"""
  id: ID!
  """transfers where this account is the sender"""
  transfersOut(skip: Int = 0, first: Int = 100, orderBy: baseTransfer_orderBy, orderDirection: OrderDirection, where: baseTransfer_filter): [baseTransfer!]!
  """transfers where this account is the receiver"""
  transfersIn(skip: Int = 0, first: Int = 100, orderBy: baseTransfer_orderBy, orderDirection: OrderDirection, where: baseTransfer_filter): [baseTransfer!]!
  """balances for each token"""
  balances(skip: Int = 0, first: Int = 100, orderBy: baseBalance_orderBy, orderDirection: OrderDirection, where: baseBalance_filter): [baseBalance!]!
}

input baseAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfersOut_: baseTransfer_filter
  transfersIn_: baseTransfer_filter
  balances_: baseBalance_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [baseAccount_filter]
  or: [baseAccount_filter]
}

enum baseAccount_orderBy {
  id
  transfersOut
  transfersIn
  balances
}

type baseBalance {
  """account address + token address"""
  id: ID!
  """the account that holds the baseBalance"""
  account: baseAccount!
  """the token"""
  token: baseToken!
  """the vault if this baseBalance belongs to one"""
  vault: baseVault
  """current baseBalance"""
  amount: BigInt!
  """block number of last update"""
  lastUpdateBlock: BigInt!
  """timestamp of last update"""
  lastUpdateTimestamp: BigInt!
}

input baseBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: baseAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: baseToken_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: baseVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lastUpdateBlock: BigInt
  lastUpdateBlock_not: BigInt
  lastUpdateBlock_gt: BigInt
  lastUpdateBlock_lt: BigInt
  lastUpdateBlock_gte: BigInt
  lastUpdateBlock_lte: BigInt
  lastUpdateBlock_in: [BigInt!]
  lastUpdateBlock_not_in: [BigInt!]
  lastUpdateTimestamp: BigInt
  lastUpdateTimestamp_not: BigInt
  lastUpdateTimestamp_gt: BigInt
  lastUpdateTimestamp_lt: BigInt
  lastUpdateTimestamp_gte: BigInt
  lastUpdateTimestamp_lte: BigInt
  lastUpdateTimestamp_in: [BigInt!]
  lastUpdateTimestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [baseBalance_filter]
  or: [baseBalance_filter]
}

enum baseBalance_orderBy {
  id
  account
  account__id
  token
  token__id
  token__name
  token__symbol
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  lastUpdateBlock
  lastUpdateTimestamp
}

type baseToken {
  """token contract address"""
  id: ID!
  """token name"""
  name: String!
  """token symbol"""
  symbol: String!
  """all transfers of this token"""
  transfers(skip: Int = 0, first: Int = 100, orderBy: baseTransfer_orderBy, orderDirection: OrderDirection, where: baseTransfer_filter): [baseTransfer!]!
}

input baseToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  transfers_: baseTransfer_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [baseToken_filter]
  or: [baseToken_filter]
}

enum baseToken_orderBy {
  id
  name
  symbol
  transfers
}

type baseTransfer {
  """transaction hash + log index"""
  id: ID!
  """the token being transferred"""
  token: baseToken!
  """sender address"""
  from: baseAccount!
  """receiver address"""
  to: baseAccount!
  """vault if this is a vault deposit"""
  vault: baseVault
  """amount transferred"""
  amount: BigInt!
  """block number"""
  blockNumber: BigInt!
  """block timestamp"""
  timestamp: BigInt!
  """transaction hash"""
  transactionHash: Bytes!
}

input baseTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: baseToken_filter
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: baseAccount_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: baseAccount_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: baseVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [baseTransfer_filter]
  or: [baseTransfer_filter]
}

enum baseTransfer_orderBy {
  id
  token
  token__id
  token__name
  token__symbol
  from
  from__id
  to
  to__id
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  blockNumber
  timestamp
  transactionHash
}

type baseVault {
  """vault address"""
  id: ID!
  """deposits received by this vault"""
  deposits(skip: Int = 0, first: Int = 100, orderBy: baseTransfer_orderBy, orderDirection: OrderDirection, where: baseTransfer_filter): [baseTransfer!]!
  """total value locked in vault per token"""
  tokenBalances(skip: Int = 0, first: Int = 100, orderBy: baseBalance_orderBy, orderDirection: OrderDirection, where: baseBalance_filter): [baseBalance!]!
  """total number of depositors"""
  totalDepositors: BigInt!
  """total value locked across all tokens"""
  totalValueLocked: BigInt!
}

input baseVault_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  deposits_: baseTransfer_filter
  tokenBalances_: baseBalance_filter
  totalDepositors: BigInt
  totalDepositors_not: BigInt
  totalDepositors_gt: BigInt
  totalDepositors_lt: BigInt
  totalDepositors_gte: BigInt
  totalDepositors_lte: BigInt
  totalDepositors_in: [BigInt!]
  totalDepositors_not_in: [BigInt!]
  totalValueLocked: BigInt
  totalValueLocked_not: BigInt
  totalValueLocked_gt: BigInt
  totalValueLocked_lt: BigInt
  totalValueLocked_gte: BigInt
  totalValueLocked_lte: BigInt
  totalValueLocked_in: [BigInt!]
  totalValueLocked_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [baseVault_filter]
  or: [baseVault_filter]
}

enum baseVault_orderBy {
  id
  deposits
  tokenBalances
  totalDepositors
  totalValueLocked
}

type scrollAccount {
  """scrollAccount address"""
  id: ID!
  """transfers where this scrollAccount is the sender"""
  transfersOut(skip: Int = 0, first: Int = 100, orderBy: scrollTransfer_orderBy, orderDirection: OrderDirection, where: scrollTransfer_filter): [scrollTransfer!]!
  """transfers where this scrollAccount is the receiver"""
  transfersIn(skip: Int = 0, first: Int = 100, orderBy: scrollTransfer_orderBy, orderDirection: OrderDirection, where: scrollTransfer_filter): [scrollTransfer!]!
  """balances for each scrollToken"""
  balances(skip: Int = 0, first: Int = 100, orderBy: scrollBalance_orderBy, orderDirection: OrderDirection, where: scrollBalance_filter): [scrollBalance!]!
}

input scrollAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfersOut_: scrollTransfer_filter
  transfersIn_: scrollTransfer_filter
  balances_: scrollBalance_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [scrollAccount_filter]
  or: [scrollAccount_filter]
}

enum scrollAccount_orderBy {
  id
  transfersOut
  transfersIn
  balances
}

type scrollBalance {
  """scrollAccount address + scrollToken address"""
  id: ID!
  """the scrollAccount that holds the scrollBalance"""
  account: scrollAccount!
  """the scrollToken"""
  token: scrollToken!
  """the scrollVault if this scrollBalance belongs to one"""
  vault: scrollVault
  """current scrollBalance"""
  amount: BigInt!
  """block number of last update"""
  lastUpdateBlock: BigInt!
  """timestamp of last update"""
  lastUpdateTimestamp: BigInt!
}

input scrollBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: scrollAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: scrollToken_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: scrollVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lastUpdateBlock: BigInt
  lastUpdateBlock_not: BigInt
  lastUpdateBlock_gt: BigInt
  lastUpdateBlock_lt: BigInt
  lastUpdateBlock_gte: BigInt
  lastUpdateBlock_lte: BigInt
  lastUpdateBlock_in: [BigInt!]
  lastUpdateBlock_not_in: [BigInt!]
  lastUpdateTimestamp: BigInt
  lastUpdateTimestamp_not: BigInt
  lastUpdateTimestamp_gt: BigInt
  lastUpdateTimestamp_lt: BigInt
  lastUpdateTimestamp_gte: BigInt
  lastUpdateTimestamp_lte: BigInt
  lastUpdateTimestamp_in: [BigInt!]
  lastUpdateTimestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [scrollBalance_filter]
  or: [scrollBalance_filter]
}

enum scrollBalance_orderBy {
  id
  account
  account__id
  token
  token__id
  token__name
  token__symbol
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  lastUpdateBlock
  lastUpdateTimestamp
}

type scrollToken {
  """scrollToken contract address"""
  id: ID!
  """scrollToken name"""
  name: String!
  """scrollToken symbol"""
  symbol: String!
  """all transfers of this scrollToken"""
  transfers(skip: Int = 0, first: Int = 100, orderBy: scrollTransfer_orderBy, orderDirection: OrderDirection, where: scrollTransfer_filter): [scrollTransfer!]!
}

input scrollToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  transfers_: scrollTransfer_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [scrollToken_filter]
  or: [scrollToken_filter]
}

enum scrollToken_orderBy {
  id
  name
  symbol
  transfers
}

type scrollTransfer {
  """transaction hash + log index"""
  id: ID!
  """the scrollToken being transferred"""
  token: scrollToken!
  """sender address"""
  from: scrollAccount!
  """receiver address"""
  to: scrollAccount!
  """scrollVault if this is a scrollVault deposit"""
  vault: scrollVault
  """amount transferred"""
  amount: BigInt!
  """block number"""
  blockNumber: BigInt!
  """block timestamp"""
  timestamp: BigInt!
  """transaction hash"""
  transactionHash: Bytes!
}

input scrollTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: scrollToken_filter
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: scrollAccount_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: scrollAccount_filter
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: scrollVault_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [scrollTransfer_filter]
  or: [scrollTransfer_filter]
}

enum scrollTransfer_orderBy {
  id
  token
  token__id
  token__name
  token__symbol
  from
  from__id
  to
  to__id
  vault
  vault__id
  vault__totalDepositors
  vault__totalValueLocked
  amount
  blockNumber
  timestamp
  transactionHash
}

type scrollVault {
  """scrollVault address"""
  id: ID!
  """deposits received by this scrollVault"""
  deposits(skip: Int = 0, first: Int = 100, orderBy: scrollTransfer_orderBy, orderDirection: OrderDirection, where: scrollTransfer_filter): [scrollTransfer!]!
  """total value locked in scrollVault per scrollToken"""
  tokenBalances(skip: Int = 0, first: Int = 100, orderBy: scrollBalance_orderBy, orderDirection: OrderDirection, where: scrollBalance_filter): [scrollBalance!]!
  """total number of depositors"""
  totalDepositors: BigInt!
  """total value locked across all tokens"""
  totalValueLocked: BigInt!
}

input scrollVault_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  deposits_: scrollTransfer_filter
  tokenBalances_: scrollBalance_filter
  totalDepositors: BigInt
  totalDepositors_not: BigInt
  totalDepositors_gt: BigInt
  totalDepositors_lt: BigInt
  totalDepositors_gte: BigInt
  totalDepositors_lte: BigInt
  totalDepositors_in: [BigInt!]
  totalDepositors_not_in: [BigInt!]
  totalValueLocked: BigInt
  totalValueLocked_not: BigInt
  totalValueLocked_gt: BigInt
  totalValueLocked_lt: BigInt
  totalValueLocked_gte: BigInt
  totalValueLocked_lte: BigInt
  totalValueLocked_in: [BigInt!]
  totalValueLocked_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [scrollVault_filter]
  or: [scrollVault_filter]
}

enum scrollVault_orderBy {
  id
  deposits
  tokenBalances
  totalDepositors
  totalValueLocked
}